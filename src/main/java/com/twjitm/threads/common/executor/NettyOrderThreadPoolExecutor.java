package com.twjitm.threads.common.executor;import com.twjitm.threads.common.logs.LoggerFactory;import com.twjitm.threads.entity.AbstractNettyTask;import com.twjitm.threads.thread.NettyThreadNameFactory;import com.twjitm.threads.thread.task.NettyOrderTaskQueue;import com.twjitm.threads.thread.task.NettyTaskQueue;import org.slf4j.Logger;import java.util.concurrent.*;import java.util.concurrent.locks.ReentrantLock;/** * * 扩展ThreadPoolExecutor 实现有序队列执行 * * @author EGLS0807 - [Created on 2018-08-23 17:45] * @company http://www.g2us.com/ * @jdk java version "1.8.0_77" * <p> * https://blog.csdn.net/u013256816/article/details/50403962 * */public class NettyOrderThreadPoolExecutor extends ThreadPoolExecutor {    private Logger logger = LoggerFactory.logger;    private ReentrantLock lock = new ReentrantLock();    private int maxTasExecutorSize;    private NettyThreadNameFactory threadNameFactory;    public NettyOrderThreadPoolExecutor(String threadName, int corePoolSize, int maxTasExecutorSize) {        super(corePoolSize, maxTasExecutorSize * 2, 30,                TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NettyThreadNameFactory(threadName));        this.maxTasExecutorSize = maxTasExecutorSize;        this.threadNameFactory = (NettyThreadNameFactory) getThreadFactory();    }    public NettyOrderThreadPoolExecutor(String threadName, int corePoolSize, int maxPollSize, int maxTasExecutorSize, RejectedExecutionHandler rejectedExecutionHandler) {        super(corePoolSize, maxPollSize, 30,                TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),                new NettyThreadNameFactory(threadName), rejectedExecutionHandler);        this.maxTasExecutorSize = maxTasExecutorSize;        this.threadNameFactory = (NettyThreadNameFactory) getThreadFactory();    }    public NettyOrderThreadPoolExecutor(String threadName, int corePoolSize, int maxTasExecutorSize, RejectedExecutionHandler rejectedExecutionHandler) {        super(corePoolSize, maxTasExecutorSize * 2, 30,                TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),                rejectedExecutionHandler);        this.maxTasExecutorSize = maxTasExecutorSize;        this.threadNameFactory = (NettyThreadNameFactory) getThreadFactory();    }    public NettyOrderThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);        this.threadNameFactory = (NettyThreadNameFactory) getThreadFactory();        this.maxTasExecutorSize = maximumPoolSize;    }    NettyOrderTaskQueue<Long, AbstractNettyTask> poll = new NettyOrderTaskQueue<Long, AbstractNettyTask>();    /**     * 添加一个任务到队列里面     *     * @param taskId     * @param task     * @return     */    public boolean addTask(long taskId, AbstractNettyTask task) {        boolean run = false;        boolean result = false;        NettyTaskQueue<AbstractNettyTask> queue = poll.getTasksQueue(taskId);        lock.lock();        if (maxTasExecutorSize > 0) {            if (queue.size() > maxTasExecutorSize) {                if (logger.isWarnEnabled()) {                    logger.warn("队列" + threadNameFactory.getThreadName() + "(" + taskId + ")" + "超过最大队列大小设置!");                }            }            result = queue.add(task);            if (result) {                task.setTaskBlockingQueue(queue);                if (queue.isComple()) {                    queue.setComple(false);                    run = true;                }            } else {                logger.info(" ADD TASK ERROR");            }            if (run) {                execute(task);            }        }        lock.unlock();        return result;    }    @Override    protected void afterExecute(Runnable r, Throwable t) {        super.afterExecute(r, t);        AbstractNettyTask work = (AbstractNettyTask) r;        NettyTaskQueue<AbstractNettyTask> queue = work.getTaskBlockingQueue();        if (queue != null) {            AbstractNettyTask afterWork = null;            synchronized (queue) {                afterWork = queue.poll();                if (afterWork == null) {                    queue.setComple(true);                }            }            if (afterWork != null) {                execute(afterWork);            }        } else {            logger.error("执行队列为空");        }    }}